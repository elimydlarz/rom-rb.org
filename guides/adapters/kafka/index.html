<!DOCTYPE html><html><head><link href="/images/favicon.png" rel="icon" type="image/png" /><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="ROM &raquo; Guides &raquo; Kafka via @rom_rb" name="twitter:description" /><meta content="ROM &raquo; Guides &raquo; Kafka" name="description" /><title>ROM &raquo; Guides &raquo; Kafka</title><style type="text/css">.highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #d0d0d0;
  background-color: #151515;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}</style><link href="../../../stylesheets/all.css" rel="stylesheet" /><script src="../../../javascripts/all.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/js/bootstrap.min.js"></script><script>$(function() {
  var share = new Share(".share")
});
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-2573270-5', 'auto');
ga('send', 'pageview');</script></head><body class="guides guides_adapters guides_adapters_kafka guides_adapters_kafka_index"><div class="page-wrapper"><header><nav class="navbar navbar-default navbar-static-top"><div class="navbar-inner"><div class="container"><a class="navbar-brand" href="/">Ruby Object Mapper</a><ul class="nav navbar-nav"><li class=""><a class="" href="/introduction">Introduction</a></li><li class=""><a class="" href="/guides">Guides</a></li><li class=""><a class="" href="/tutorials">Tutorials</a></li><li class="dropdown"><a class="dropdown-toggle" role="button" data-toggle="dropdown" href="#">API <span class='caret'/></a><ul class="dropdown-menu" role="menu"><li><a href="http://www.rubydoc.info/gems/rom">rom</a></li><li><a href="http://www.rubydoc.info/gems/rom-sql">rom-sql</a></li><li><a href="http://www.rubydoc.info/gems/rom-yesql">rom-yesql</a></li><li><a href="http://www.rubydoc.info/gems/rom-influxdb">rom-influxdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-event_store">rom-event_store</a></li><li><a href="http://www.rubydoc.info/gems/rom-rethinkdb">rom-rethinkdb</a></li><li><a href="http://www.rubydoc.info/gems/rom-mongo">rom-mongo</a></li><li><a href="http://www.rubydoc.info/gems/rom-redis">rom-redis</a></li><li><a href="http://www.rubydoc.info/gems/rom-csv">rom-csv</a></li><li><a href="http://www.rubydoc.info/gems/rom-yaml">rom-yaml</a></li><li><a href="http://www.rubydoc.info/gems/rom-dm">rom-dm</a></li><li><a href="http://www.rubydoc.info/gems/rom-lotus">rom-lotus</a></li><li><a href="http://www.rubydoc.info/gems/rom-rails">rom-rails</a></li><li><a href="http://www.rubydoc.info/gems/rom-roda">rom-roda</a></li></ul></li><li class=""><a class="" href="/blog">Blog</a></li><li class=""><a class="" href="/contribute">Contribute</a></li><li class=""><a class="" href="/status">Status</a></li><li class=""><a class="" href="/backers">Backers <3</a></li></ul></div></div></nav></header><div class="container"><div class="content"><div class="row"><div class="col-md-3"><ul class="nav nav-pills nav-stacked"><li class="nav-heading"><a class="nav-heading" href="/guides/basics/setup">Setup</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/repositories">Repositories</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/relations">Relations</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/commands">Commands</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/basics/mappers">Mappers</a></li><li class="nav-heading"><a class="nav-heading" href="/guides/adapters">Adapters</a></li><li class=""><a class="" href="/guides/adapters/how-to">How-to</a></li><li class=""><a class="" href="/guides/adapters/sql">SQL</a></li><li class=""><a class="" href="/guides/adapters/cassandra">Cassandra</a></li></ul></div><div class="col-md-9"><div class="page-article"><h1 id="kafka-adapter">Kafka Adapter</h1>

<p>ROM supports <a href="http://kafka.apache.org/">Apache Kafka</a> via <a href="https://github.com/rom-rb/rom-kafka">rom-kafka</a> adapter, that is built on top of the <a href="https://github.com/bpot/poseidon">poseidon</a> ruby driver.</p>

<p><em>Before v0.0.1 the adapter is still in alpha/beta. If you find any inconsistency, please feel free to ask your questions at the <a href="https://gitter.im/rom-rb/chat">ROM chatroom</a> and report issues <a href="https://github.com/rom-rb/rom-kafka">on github</a>.</em></p>

<h2 id="intro">Intro</h2>

<p>The adapter provides access to Kafka brokers in much the same way as other adapters do for corresponding datastores with some specifics:</p>

<ul>
<li><p>By the very nature of Kafka, it allows only creating (publishing) messages, and reading (consuming) them. No &lsquo;update&rsquo; and &#39;delete&rsquo; commands are available.</p></li>
<li><p>Reading messages from Kafka also differs from what you&rsquo;d expect from a database. Kafka only supports reading a sequence of messages from a <em>topic</em>&rsquo;s <em>partition</em>, starting from some <em>offset</em> . You can neither reorder messages or filter them in any way. That operations are up to domain application. All you can define is the topic (<a href="#relation">relation</a>), its <a href="#partition">partition</a>, the initial <a href="#offset">offset</a>, and <a href="#limit">limit</a> the number of messages to output.</p></li>
</ul>

<h2 id="setup">Setup</h2>

<p>Set a Kafka gateway in a <a href="http://rom-rb.org/guides/basics/setup">ROM generic way</a>. When setting a gateway you have to specify the <code>client_id</code> and a list of Kafka brokers.
Brokers can be set in the following ways:</p>
<pre class="highlight ruby"><code><span class="c1"># by default (connects to host 'localhost', port 9092)</span>
<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># with inline address (host:port)</span>
<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'localhost:9092'</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># ...or a list of addresses</span>
<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1:9092'</span><span class="p">,</span> <span class="s1">'127.0.0.2:9092'</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># with explicit array of `hosts` and `port`</span>
<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="ss">hosts: </span><span class="p">[</span><span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="s1">'127.0.0.2'</span><span class="p">],</span> <span class="ss">port: </span><span class="mi">9092</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>

<span class="c1"># or their combination (the same as '127.0.0.1:9092', '127.0.0.1:9093')</span>
<span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span><span class="ss">:kafka</span><span class="p">,</span> <span class="s1">'127.0.0.1'</span><span class="p">,</span> <span class="ss">hosts: </span><span class="p">[</span><span class="s1">'127.0.0.2:9093'</span><span class="p">],</span> <span class="ss">port: </span><span class="mi">9092</span><span class="p">,</span> <span class="ss">client_id: :admin</span><span class="p">)</span>
</code></pre>

<h3 id="additional-options">Additional options</h3>

<p>In addition to <code>brokers</code> and <code>client_id</code> you can use the following options:</p>

<p>| Attribute | Type | Default value | Description |
| &mdash;&mdash;&mdash; | &mdash;- | &mdash;&mdash;&mdash;&mdash;- | &mdash;&mdash;&mdash;&ndash; |
| <code>:partitioner</code> | <code>Proc</code>, <code>nil</code> | <code>nil</code> | A proc used to define partition by key. |
| <code>:compression_codec</code> | <code>:gzip</code>, <code>:snappy</code>, <code>nil</code> | <code>nil</code> | The type of compression to be used. |
| <code>:metadata_refresh_interval_ms</code> | <code>Integer</code> | <code>600_000</code> | How frequently the topic metadata should be updated (in milliseconds). |
| <code>:max_send_retries</code> | <code>Integer</code> | <code>3</code> | The number of times to retry sending of messages to a Kafka leader. |
| <code>:retry_backoff_ms</code> | <code>Integer</code> | <code>100</code> | The amount of time (in milliseconds) to wait before refreshing the metadata after we are unable to send messages. |
| <code>:required_acks</code> | <code>Integer</code> | <code>0</code> | The number of acks required per request. |
| <code>:ack_timeout_ms</code> | <code>Integer</code> | <code>1_500</code> | How long the producer waits for acks. |
| <code>:socket_timeout_ms</code> | <code>Integer</code> | <code>10_000</code> | How long the producer/consumer socket waits for any reply from server. |
| <code>:min_bytes</code> | <code>Integer</code> | <code>1</code> | The smallest amount of data the server should send (By default send data as soon as it is ready). |
| <code>:max_bytes</code> | <code>Integer</code> | <code>1_048_576</code> | The maximum number of bytes to fetch by consumer (1MB by default). |
| <code>:max_wait_ms</code> | <code>Integer</code> | <code>100</code> | How long to block until the server sends data.  This is only enforced if min_bytes is &gt; 0. |</p>

<h3 id="partitioner">Partitioner</h3>

<p>With the <code>:partitioner</code> option you can specify a procedure to define a partition by key. The procedure should take 2 arguments for key and number of partitions, and return the integer value for a partition.</p>

<p>In the following example a message is added to a corresponding partition depending on number of letters in a key:</p>
<pre class="highlight ruby"><code><span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span>
  <span class="ss">:kafka</span><span class="p">,</span>
  <span class="ss">client_id: :admin</span><span class="p">,</span>
  <span class="ss">partitioner: </span><span class="o">-&gt;</span> <span class="n">key</span><span class="p">,</span> <span class="n">number</span> <span class="p">{</span> <span class="n">key</span><span class="p">.</span><span class="nf">count</span> <span class="o">%</span> <span class="n">number</span> <span class="p">}</span>
<span class="p">)</span>

<span class="c1">#...</span>

<span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span>
<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">env</span>
<span class="n">insert</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:items</span><span class="p">).</span><span class="nf">create</span>

<span class="c1"># Suppose the topic "items" has 3 partitions (0 and 1).</span>
<span class="c1"># Messages "bar" and "baz" will be added to the partition 1 ("foo".count % 2 = 1).</span>
<span class="n">insert</span><span class="p">.</span><span class="nf">with</span><span class="p">(</span><span class="ss">key: </span><span class="s2">"foo"</span><span class="p">).</span><span class="nf">call</span> <span class="s2">"bar"</span><span class="p">,</span> <span class="s2">"baz"</span>
</code></pre>

<h3 id="compression">Compression</h3>

<p>To use snappy compression, install the <a href="https://github.com/miyucy/snappy">snappy</a> gem, or simply add gem &#39;snappy&rsquo; to your project&rsquo;s Gemfile.</p>

<h2 id="relations">Relations</h2>

<p>In <code>ROM::Kafka</code> the relation describes a topic. You can read messages from a specific partition from a specified offset.
By default both the partition and initial offset are set to 0.</p>

<p>To define a Kafka relation follow <a href="http://rom-rb.org/guides/basics/relations/">the standard way of defining relations</a> in ROM.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Greetings</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Relation</span><span class="p">[</span><span class="ss">:kafka</span><span class="p">]</span>
  <span class="n">topic</span> <span class="ss">:greetings</span> <span class="c1"># kafka-specific alias for `relation :greetings`</span>
<span class="k">end</span>
</code></pre>

<p>To define relations that are exposed to you application you can define your own methods using dataset modifiers:</p>

<ul>
<li><code>#from</code> to define a partition to read data from (0 by default).</li>
<li><code>#offset</code> to define a <em>starting</em> offset to start reading from (0 by default).</li>
<li><code>#limit</code> to define a number of messages to be fetched.</li>
<li><code>#using</code> to modify any option of the setup.</li>
</ul>

<p>The relation <code>call</code> method returns an array of tuples with 4 keys:</p>

<ul>
<li><code>value</code> for the message.</li>
<li><code>topic</code> for the current topic.</li>
<li><code>key</code> for the current key.</li>
<li><code>offset</code> for the offset of the current message.</li>
</ul>
<pre class="highlight ruby"><code><span class="c1"># After the setup</span>
<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>
<span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>

<span class="c1"># Selects all messages from the (default) partition 0</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi!", topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#      { value: "Hello!", topic: "greetings", key: nil, offset: 1 }</span>
<span class="c1">#    ]</span>
</code></pre>

<h3 id="partition">Partition</h3>

<p>By default messages are read from 0 partition. You can explicitly select the partition to read from:</p>
<pre class="highlight ruby"><code><span class="c1"># Will read all messages from the partition 1 of the "greetings" topic</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">to_a</span>
</code></pre>

<h3 id="using-options">Using options</h3>

<p>Kafka allows reading messages from given offset. Messages are fetched by chunks - you can set a maximum and minimum length (in bytes), as well as the wait time for the server to responce.</p>

<p>This options can be set for a gateway during the <a href="#setup">setup phase</a>:</p>
<pre class="highlight ruby"><code><span class="no">ROM</span><span class="p">.</span><span class="nf">setup</span><span class="p">(</span>
  <span class="ss">:kafka</span><span class="p">,</span>
  <span class="ss">client_id: :admin</span><span class="p">,</span>
  <span class="ss">min_bytes: </span><span class="mi">1_024</span><span class="p">,</span>  <span class="c1"># ignore data less then 1Kb</span>
  <span class="ss">max_bytes: </span><span class="mi">10_240</span><span class="p">,</span> <span class="c1"># read nor more than 10Kb at once</span>
  <span class="ss">max_wait_ms: </span><span class="mi">100</span>   <span class="c1"># wait for responce no longer than 100ms</span>
<span class="p">)</span>
</code></pre>

<p>or you can update them with <code>using</code> method:</p>
<pre class="highlight ruby"><code><span class="c1"># read all messages whatever length they have, and wait for the request up to second</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">from</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="nf">using</span><span class="p">(</span><span class="ss">min_bytes: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">max_wait_ms: </span><span class="mi">1_000</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
</code></pre>

<h3 id="offset">Offset</h3>

<p>When Kafka reads messages from topic/partition, it stops at some offset. This can be an offset of the last message (at the time of reading).</p>

<p>If in some period of time you&rsquo;ll make another call, it start reading messages from the next offset (only new ones).</p>
<pre class="highlight ruby"><code><span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi",    topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 }</span>
<span class="c1">#    ]</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [] (because all messages has bean read diring the first call)</span>
<span class="nb">sleep</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hola", topic: "greetings", key: nil, offset: 2 }</span>
<span class="c1">#    ]</span>
<span class="c1"># (only messages being added after the previous call)</span>
</code></pre>

<p>If you need to restart reading from a specific offset, you can do it by setting <code>offset</code> explicitly:</p>
<pre class="highlight ruby"><code><span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">).</span><span class="nf">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">call</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 },</span>
<span class="c1">#    ]</span>
</code></pre>

<p>You can use info from the last extracted tuple to define an offset, from which to start the next time.</p>

<h3 id="limit">Limit</h3>

<p>You can define a maximum number of messages to return, using the <code>limit</code> method:</p>
<pre class="highlight ruby"><code><span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">2</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 },</span>
<span class="c1">#      { value: "Hola",  topic: "greetings", key: nil, offset: 2 }</span>
<span class="c1">#    ]</span>
</code></pre>

<p>But be careful. Actual size of data being read is defined by <code>:max_bytes</code> settings, not the offset.</p>

<p>For example, when you set <code>offset(2)</code>, the relation can actually fetch the chunk of 5 messages (and move the next offset correspodingly). If you continue reading, you&rsquo;ll miss 3 messages. That&rsquo;s why it is <strong>strongly recommended</strong> to set <code>offset</code> explicitly after using of <code>limit</code> modifier.</p>

<p>This is unsafe (can cause missing messages):</p>
<pre class="highlight ruby"><code><span class="n">greetings</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">relation</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi",    topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#    ]</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; []</span>
</code></pre>

<p>while this is pretty safe:</p>
<pre class="highlight ruby"><code><span class="n">greetings</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi",    topic: "greetings", key: nil, offset: 0 },</span>
<span class="c1">#    ]</span>
<span class="n">greetings</span><span class="p">.</span><span class="nf">offset</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">call</span><span class="p">.</span><span class="nf">to_a</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hello", topic: "greetings", key: nil, offset: 1 },</span>
<span class="c1">#      { value: "Hola",  topic: "greetings", key: nil, offset: 2 }</span>
<span class="c1">#    ]</span>
</code></pre>

<p>Also notice, that every time you use modifier, the new connection is re-established. That&rsquo;s why the <strong>rule of thumb</strong> is either not using modifiers at all, or set the offset explicitly for every call.</p>

<h2 id="commands">Commands</h2>

<p>Kafka supports the <code>Create</code> <a href="http://rom-rb.org/guides/basics/commands/">command only</a>. You can only add immutable messages to the log, but not to change or delete them.</p>

<p><code>ROM::Kafka</code> provides two helpers for command: <code>#where</code> and <code>#using</code>.</p>
<pre class="highlight ruby"><code><span class="k">class</span> <span class="nc">Greet</span> <span class="o">&lt;</span> <span class="no">ROM</span><span class="o">::</span><span class="no">Commands</span><span class="o">::</span><span class="no">Create</span><span class="p">[</span><span class="ss">:kafka</span><span class="p">]</span>
  <span class="n">relation</span> <span class="ss">:greetings</span>
  <span class="n">register_as</span> <span class="ss">:greet</span>

  <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="k">super</span> <span class="n">where</span><span class="p">(</span><span class="ss">key: </span><span class="s2">"foo"</span><span class="p">).</span><span class="nf">using</span><span class="p">(</span><span class="ss">socket_timeout_ms: </span><span class="mi">10</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Here <code>where</code> modifier requires only one value for a <code>:key</code>. The <code>using</code> modifier accepts any value you&rsquo;ll get, but will ignore unused ones. You&rsquo;re recommended to use only <a href="#additional-options">those keys</a> that are defined for the producer:</p>

<ul>
<li>partitioner</li>
<li>compression_codec</li>
<li>metadata<em>refresh</em>interval_ms</li>
<li>max<em>send</em>retries</li>
<li>retry<em>backoff</em>ms</li>
<li>required_acks</li>
<li>ack<em>timeout</em>ms</li>
<li>socket<em>timeout</em>ms</li>
</ul>

<p>In case of success the command returns an array of messages added to Kafka:</p>
<pre class="highlight ruby"><code><span class="c1"># After the setup</span>
<span class="n">rom</span> <span class="o">=</span> <span class="no">ROM</span><span class="p">.</span><span class="nf">finalize</span><span class="p">.</span><span class="nf">env</span>
<span class="n">greet</span> <span class="o">=</span> <span class="n">rom</span><span class="p">.</span><span class="nf">command</span><span class="p">(</span><span class="ss">:greetings</span><span class="p">).</span><span class="nf">greet</span>

<span class="n">greet</span><span class="p">.</span><span class="nf">call</span> <span class="s2">"Hi, Joe"</span><span class="p">,</span> <span class="s2">"How're you?"</span>
<span class="c1"># =&gt; [</span>
<span class="c1">#      { value: "Hi, Joe",     topic: "greetings", key: 0 },</span>
<span class="c1">#      { value: "How're you?", topic: "greetings", key: 0 }</span>
<span class="c1">#    ]</span>
</code></pre>

<p>Because producer and consumer connection to Kafka brokers are separated. That&rsquo;s why a command actually not reading messages and knows nothing about their partition and offset (defined by server). You have to read them explicitly if you need (but do you?).</p>

<h2 id="mappers">Mappers</h2>

<p>Mappers can be applied to relations and commands in a <a href="http://rom-rb.org/guides/basics/mappers">standard ROM way</a>.</p>
<div class="page-article-edit"><hr /><div class="share pull-left"></div><p class="pull-right">Edit this article on <a href="https://github.com/rom-rb/rom-rb.org/tree/master/source/doc-pages/guides/adapters/kafka.md">GitHub</a></p></div></div></div></div></div></div></div><footer><div class="container"><div class="social"><div class="github"><iframe allowtransparency="true" frameborder="0" height="20" scrolling="0" src="http://ghbtns.com/github-btn.html?user=rom-rb&repo=rom&type=watch&count=true" width="110"></iframe></div><div class="twitter"><a class="twitter-follow-button" data-show-count="true" data-show-screen-name="false" href="https://twitter.com/rom_rb">Follow</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script></div></div><div class="muted copyright">Ruby Object Mapper &copy; 2014-2015</div></div></footer></body></html>